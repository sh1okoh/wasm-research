★参考：https://zenn.dev/0kate/articles/7716f37f7fc327
　（ただし，いろいろ間違いが含まれているように見える．）

★サイズに関しては，リトルエンディアンとしている．
　つまり，後から出てくる値を左に 7 -> 14 -> 21 ビットシフトして論理和していく．

★block（loopなども？）に入ったら，それまでのスタック（の値）は使用できないらしい．
　代わりに，ブロック用の新しいスタックが用意されるイメージらしい．
　（ただし，以下の結果データの関係から，旧スタックの上に乗せるが良いだろう．）
　result typeを指定しない場合は，スタックを空にしてからブロックを抜けなければならないらしい．otherwise, error happens.
　ブロックを抜けた後に結果データを使用したい場合は，result typeを指定すると可能となる．

  Very useful URL: https://openhome.cc/eGossip/WebAssembly/Block.html

★blockやloopが出てくる度に，control-flowスタックに“エントリ”をプッシュする．

  block 0x40, loop  0x40 のように，0x40(empty)で使用されている．
　br 0, br_if 1 などのように，control-flowスタックの深さ（何段抜けるか）を指定して，その場所／ラベルにジャンプする．

　if i32 のように，if文は終了時点でスタックになにが積まれるか（result i32）を明示する．（何も積まない場合にはemptyか？）

★br_table は，スタックからpopした値をインデックスとして分岐する先を指定する．
　"br_table $a, $b, $c"の場合は，pop値が0,1,2の場合，それぞれ$a, $b, $cブロック（の出口）にジャンプする．
　対応する値が無い場合は，最後のラベルにジャンプするらしい．

　br_tableは，以下の即値オペランドを持つ
	target_count: target_tableのエントリ数
	target_table: varuint32* 分岐する対象の親ブロック列
	default_target: varuint32 デフォルトで分岐するブロック



00	先頭マーク
61	'a'
73	's'
6D	'm'

01	4-byte バージョンナンバー
00	"00000001"＝バージョン１ (リトルエンディアン)
00
00

[WEB]------------------------------------------------------
01	"1" = タイプセクション
06	following "6" bytes explain a type
01	"1" = 定義されているFunction Typesの数
60	"60" = 関数型
01	"01" = 関数の引数の数
7F	"7F" = "i32" (引数の型)
01	"01" = 戻り値の数
7F	"7F" = "i32" (リターンの型)
------------------------------------------------------


[wasm_example.wasm]------------------------------------------------------
01	"1" = タイプセクション
07	following "7" bytes explain a type
01	"1" = 定義されているFunction Typesの数
60	"60" = 関数型
02	"02" = 関数の引数の数
7F	"7F" = "i32" (引数の型)
7F	"7F" = "i32" (引数の型)
01	"01" = 戻り値の数
7F	"7F" = "i32" (リターンの型)
-----------------
03	"3" = ファンクションセクション
03	following "3" bytes explains a function　＝　正式には，シグネチャの要素数（要素数＝＝セクションサイズになる）
02	"02" = 関数の個数
00	"00" = 関数のType section内でのインデックス
00	"00" = 関数のType section内でのインデックス
-----------------
05	"5" = メモリセクション
03	following "3" bytes explain a memory
01	メモリの数
00	"00" means that the followings indicate only minimum exists (not having maximum)
11	最小値 0x11=17ページ
-----------------
07	"7" = エクスポートセクション
1B	following 1B bytes explain the export section	(0x1B = 27)
03	エクスポートする要素の数（= 3）
06	要素名の長さ (= 6 bytes)
6D	'm'
65	'e'
6D	'm'
6F	'o'
72	'r'
79	'y'
02	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
00	要素インデックス
08	要素名の長さ (= 8 bytes)
6D	'm'
75	'u'
6C	'l'
74	't'
69	'i'
70	'p'
6C	'l'
79	'y'
00	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
01	要素インデックス
03	要素名の長さ (= 3 bytes)
61	'a'
64	'd'
64	'd'
00	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
00	要素インデックス
-----------------
0A	"0A" = コードセクション
11	following 16 bytes show codes.
02	コードの数 (= 2個)
07	コードのサイズ (= 7 bytes)
00	ローカル変数の個数 (= 0個)
20	get_local ($0) (渡された値をスタックに保存する)
00	（"$0": get_local の引き数）
20	get_local ($1) (渡された値をスタックに保存する)
01	（"$1": get_local の引き数）
6A	i32.add
0B	コードの終わり(終端)
07	コードのサイズ (= 7 bytes)
00	ローカル変数の個数 (= 0個)
20	get_local ($0) (渡された値をスタックに保存する)
00	（"$0": get_local の引き数）
20	get_local ($1) (渡された値をスタックに保存する)
01	（"$1": get_local の引き数）
6C	i32.mul
0B	コードの終わり(終端)
-----------------
00	"00" = カスタムセクション
6F	following 111 bytes show custom section information.
09
70
72

6F
64
75
63
65
72
73
02

08
6C
61
6E
67
75
61
67

------------------------------------------------------

03	"3" = ファンクションセクション
02	following "2" bytes explains a function　＝　正式には，シグネチャの要素数（要素数＝＝セクションサイズになる）
01	"01" = 関数の個数
00	"00" = 関数のType section内でのインデックス

04	"4" = テーブルセクション
05	following "5" bytes explains a table
01	テーブルの数
70	「関数への参照(reference)」タイプ
01	フラグ：maximumフィールドがあるかどうか
01	最小 1エントリ（初期の数）
01	最大 1エントリ（resizableの上限）（これがmaximumフィールド）

05	"5" = メモリセクション
03	following "3" bytes explain a memory
01	メモリの数
00	"00" means that the followings indicate only minimum exists (not having maximum)
10	最小値 0x10=16ページ

06	"6" = グローバルセクション
19	following 19 bytes explain the global section (0x19 = 25 in decimal)
03	グローバル変数の数 = 3個
7F	変数の型：i32
01	可変性＝var
41	i32.const	以下の初期値は 1,048,576 = 00 10 00 00，　リトルエンディアン＆u32多倍長ルール！
80	0x80 -> 00000000
80	0x80 -> 000000000000000 + 00000000
C0	0xC0 -> (01000000 << 14) + 000000000000000 + 00000000 = 1_0000_0000_0000_0000_0000
00	0x00 -> as a result, 00 10 00 00
0B	terminate value
7F	変数の型：i32
00	可変性＝const
41	i32.const
80	00
80	00
C0	40
00	00
0B	terminate value
7F	変数の型：i32
00	可変性＝const
41	i32.const
80	00
80	00
C0	40
00	00
0B	terminate value

07	"7" = エクスポートセクション
2D	following 2D bytes explain the export section	(0x2D = 45)
04	エクスポートする要素の数（= 4）
06	要素名の長さ (= 6 bytes)
6D	'm'
65	'e'
6D	'm'
6F	'o'
72	'r'
79	'y'
02	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
00	要素インデックス
05	要素名の長さ (= 5 bytes)
74	't'
77	'w'
69	'i'
63	'c'
65	'e'
00	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
00	要素インデックス
0A	要素名の長さ (= 10 bytes)
5F	'_'
5F	'_'
64	'd'
61	'a'
74	't'
61	'a'
5F	'_'
65	'e'
6E	'n'
64	'd'
03	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
01	要素インデックス(global section内でのインデックス)
0B	要素名の長さ (= 11 bytes)
5F	'_'
5F	'_'
68	'h'
65	'e'
61	'a'
70	'p'
5F	'_'
62	'b'
61	'a'
73	's'
65	'e'
03	kind = エクスポートされた定義の種類（00:func, 01:table, 02: mem, 03: global）
02	要素インデックス(global section内でのインデックス)

0A	"0A" = コードセクション
09	following 9 bytes show codes.
01	コードの数 (= 1個)
07	コードのサイズ (= 7 bytes)
00	ローカル変数の個数 (= 0個)
20	get_local $0 (渡された値をスタックに保存する)
00	（get_local の引き数）
41	i32.const 1 (1をスタックに保存する)
01	（i32.const の引き数）
74	i32.shl (左にシフトする)
0B	コードの終わり(終端)

00	"00" = カスタムセクション
0F
04
6E
61
6D
65
01
08
01
00
05
74
77
69
63
65

----------------------------------------------------------------------------------------------------
[型を表現する値]
7F: i32
7E: i64
7D: f32
7C: f64
7B: Vector type (128bit幅分の領域で，このサイズに収まるように自由な組み合わせで値をぶっこめる複合型)（≠ Vectors）
70: funcref (関数への参照)
6F: externref (外部から差し込まれる値への参照)
60: Function type
40: Result type
  : Table type
  : Memory type
  : Blobal type

Vectors: u32で先頭にサイズを定義し，その数だけ値が続く．

[サンプルソース]
fn main() {
    println!("Hello, Wasm!");
}

[バイトコード]
00000000  00 61 73 6d 01 00 00 00  01 74 11 60 00 00 60 01  |.asm.....t.`..`.|
00000010  7f 00 60 01 7f 01 7e 60  02 7f 7f 00 60 01 7f 01  |..`...~`....`...|
00000020  7f 60 02 7f 7f 01 7f 60  03 7f 7f 7f 00 60 03 7f  |.`.....`.....`..|
00000030  7f 7f 01 7f 60 04 7f 7f  7f 7f 01 7f 60 00 01 7f  |....`.......`...|
00000040  60 05 7f 7f 7f 7f 7f 00  60 04 7f 7f 7f 7f 00 60  |`.......`......`|
00000050  05 7f 7f 7f 7f 7f 01 7f  60 07 7f 7f 7f 7f 7f 7f  |........`.......|
00000060  
00000070  
00000080  
00000090  
000000a0  
000000b0  
000000c0  
000000d0  
000000e0  11 65 6e 76 69 72 6f 6e  5f 73 69 7a 65 73 5f 67  |.environ_sizes_g|
000000f0  65 74 00 05 16 77 61 73  69 5f 73 6e 61 70 73 68  |et...wasi_snapsh|
00000100  6f 74 5f 70 72 65 76 69  65 77 31 09 70 72 6f 63  |ot_preview1.proc|
...


01 ------------------------------------------ Section ID (= Type Section)
   74 --------------------------------------- セクション内のサイズ (= 116 bytes)
      11 ------------------------------------ 定義されているFunction Typeの数 (= 17個)
         60 00 00 --------------------------- (void) -> void (00 = 無し)
         60 01 7f 00 ------------------------ (i32) -> void (1個のi32，リターン無し)
         60 01 7f 01 7e --------------------- (i32) -> i64
         60 02 7f 7f 00 --------------------- (i32, i32) -> void
         60 01 7f 01 7f --------------------- (i32) -> i32
         60 02 7f 7f 01 7f ------------------ (i32, i32) -> i32
         60 03 7f 7f 7f 00 ------------------ (i32, i32, i32) -> void
         60 03 7f 7f 7f 01 7f --------------- (i32, i32, i32) -> i32
         60 04 7f 7f 7f 7f 01 7f ------------ (i32, i32, i32, i32) -> i32
         60 00 01 7f ------------------------ (void) -> i32
         60 05 7f 7f 7f 7f 7f 00 ------------ (i32, i32, i32, i32, i32) -> void
         60 04 7f 7f 7f 7f 00 --------------- (i32, i32, i32, i32) => void
         60 05 7f 7f 7f 7f 7f 01 7f --------- (i32, i32, i32, i32, i32) -> i32
         60 07 7f 7f 7f 7f 7f 7f 7f 00 ------ (i32, i32, i32, i32, i32, i32, i32) -> void 
         60 06 7f 7f 7f 7f 7f 7f 01 7f ------ (i32, i32, i32, i32, i32, i32) -> i32
         60 07 7f 7f 7f 7f 7f 7f 7f 01 7f --- (i32, i32, i32, i32, i32, i32, i32) -> i32
         60 03 7e 7f 7f 01 7f --------------- (i64, i32, i32) -> i32


