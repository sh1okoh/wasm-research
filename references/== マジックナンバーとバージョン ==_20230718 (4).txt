== マジックナンバーとバージョン ==
00
61
73
6D
01
00
00
00
== マジックナンバーとバージョン おわり==


== 型セクション ==
01 セクション番号
91 0b10010001 -> 0010001
80 0b10000000 -> 0000000
80 0b10000000 -> 0000000
80 0b10000000 -> 0000000
00: 0b0000000 -> 0000000 ここまでサイズ → 0010001 = 2^0 + 2^4 = 17バイト
04: 4つの関数型を示す
60: func
00: パラメータの数 (0)
01: 返り値の数 (1)
7F: i32
60: func
00: パラメータの数 (0)
00: 返り値の数 (0)
60: func
01: パラメータの数 (1)
7F: i32 (パラメータの型)
00: 返り値の数 (0)
60: func
01: パラメータの数 (1)
7F: i32 (パラメータの型)
01: 返り値の数 (1)
7F: i32 (返り値の型)
== 型セクション おわり==

== インポートセクション ==
02: インポートセクションを示す
A4: 0b10100100  -> 0100100
80: 0b10000000 -> 0000000
80: 0b10000000 -> 0000000
80: 0b10000000 -> 0000000
00: 0b00000000 -> 0000000 100100 -> 2^2 + 2^5 -> 36バイト

01: 一つのインポートエントリ : 外部のモジュールから関数、グローバル変数、メモリ、テーブルをインポートするためのエントリ
16: モジュール名の長さ (22バイト)
77: w
61: a
73: s
69: i
5F: _
73: s
6E: n
61: a
70: p
73: s
68: h
6F: o
74: t
5F: _
70: p
72: r
65: e
76: v
69: i
65: e
77: w
31: 1
09: 9バイト
70: p
72: r
6F: o
63: c
5F: _
65: e
78: x
69: i
74: t
00: インポートの種類 (0は関数を示す)
02: インポートされる関数は、型セクションの3番目の型 (LEB128エンコード)
== インポートセクション おわり==

== 関数セクション ==
03 関数セクションを示す
92 ここからサイズ
80
80
80
00	ここまでサイズ → 0x12 = 18バイト

11: LEB128エンコードされたベクトルの長さ (17関数)
01: 2番目の型
03: 4番目の型
00: 1番目の型
01: 2番目の型
01: 2番目の型
01: 2番目の型
02: 3番目の型
02: 3番目の型
00: 1番目の型
02: 3番目の型
03: 4番目の型
00: 1番目の型
01: 2番目の型
00: 1番目の型
00: 1番目の型
00: 1番目の型
00: 1番目の型
== 関数セクション おわり==

== テーブルセクション ==
04
85	ここからサイズ
80
80
80
00	ここまでサイズ → 0x5 = 5バイト
01: EB128エンコードされたベクトルの長さ (1つのテーブル)
70: テーブルの要素の型 (0x70はfuncrefを示す)
01: テーブルのフラグ (1は最大サイズが存在することを示す)
02: テーブルの最小サイズ (2)
02:  テーブルの最小サイズ (2)
== テーブルセクション おわり==

== メモリセクション ==
05
86	ここからサイズ
80
80
80
00	ここまでサイズ → 0x6 = 6バイト
01 LEB128エンコードされたベクトルの長さ (1つのメモリ)
01 メモリのフラグ (1は最大サイズが存在することを示す)
80 メモリの最小サイズ (LEB128エンコード: 0x2 = 2ページ)
02
80 メモリの最小サイズ (LEB128エンコード: 0x2 = 2ページ)
02
== メモリセクション おわり==

== グローバルセクション ==
06
92	ここからサイズ
80
80
80
00	ここまでサイズ → 0x12 = 18バイト
03: LEB128エンコードされたベクトルの長さ (3つのグローバル変数)
---
7F: 型 (i32)
01: ミュータビリティ (1は変更可能)
41: i32.const命令
80:  LEB128エンコードされた数値 (-524288)
80:
04:
0B: end命令
--
7F: 型 (i32)
01: ミュータビリティ (1は変更可能)
41: i32.const命令
00: 数値 (0)
0B: end命令
-- 
7F: 型 (i32)
01: ミュータビリティ (1は変更可能)
41: i32.const命令
00: 数値 (0) 
0B: end命令
== グローバルセクション おわり==

== エクスポートセクション ==
07
F4	ここからサイズ
81
80
80
00	ここまでサイズ → 0xF4 = 244バイト
0C: LEB128エンコードされたベクトルの長さ (12エクスポート)
06: 名前の長さ (6バイト)
6D: "m"
65: "e"
6D: "m"
6F: "o"
72: "r"
79: "y"
02: エクスポートの種類 (2はメモリを示す)
00: メモリのインデックス

19: 名前の長さ (25バイト)
5F: -
5F: -
69: i
6E: n
64: d
69: i
72: r
65: e
63: c
74: t
5F: _
66: f
75: u
6E: n 
63: c
74: t
69: i
6F: o
6E: n
5F: _
74: t
61: a
62: b
6C: l
65: e
01: 1はテーブルを示す
00: テーブルのインデックス

06: 名前の長さ (6バイト)
5F: _
73: s
74: t
61: a
72: r
74: t
00: エクスポートの種類 (0は関数を示す)
04: 関数のインデックス

10: 名前の長さ (16バイト)
5F: __errno_location
5F
65
72
72
6E
6F
5F
6C
6F
63
61
74
69
6F
6E
00: エクスポートの種類 (0は関数を示す)
11: 関数のインデックス

15: 名前の長さ (21バイト)
65: emscripten_stack_init
6D
73
63
72
69
70
74
65
6E
5F
73
74
61
63
6B
5F
69
6E
69
74
00: エクスポートの種類 (0は関数を示す)
0D: 関数のインデックス

19: 名前の長さ (25バイト)
65: emscripten_stack_get_free
6D
73
63
72
69
70
74
65
6E
5F
73
74
61
63
6B
5F
67
65
74
5F
66
72
65
65
00: エクスポートの種類 (0は関数を示す)
0E: 関数のインデックス

19: 名前の長さ (25バイト)
65: emscripten_stack_get_base
6D
73
63
72
69
70
74
65
6E
5F
73
74
61
63
6B
5F
67
65
74
5F
62
61
73
65
00: エクスポートの種類 (0は関数を示す)
0F: 関数のインデックス

18: 名前の長さ (24バイト)
65: emscripten_stack_get_end
6D
73
63
72
69
70
74
65
6E
5F
73
74
61
63
6B
5F
67
65
74
5F
65
6E
64
00: エクスポートの種類 (0は関数を示す)
10: 関数のインデックス

09: 名前の長さ (9バイト)
73: stackSave
74
61
63
6B
53
61
76
65
00: エクスポートの種類 (0は関数を示す)
09: 関数のインデックス

0C: 名前の長さ (12バイト)
73: stackRestore
74
61
63
6B
52
65
73
74
6F
72
65
00: エクスポートの種類 (0は関数を示す)
0A: 関数のインデックス

0A: 名前の長さ (10バイト)
73: stackAlloc
74: 
61
63
6B
41
6C
6C
6F
63
00: エクスポートの種類 (0は関数を示す)
0B: 関数のインデックス

1C
65
6D
73
63
72
69
70
74
65
6E
5F
73
74
61
63
6B
5F
67
65
74
5F
63
75
72
72
65
6E74000C
== エクスポートセクション おわり==

== エレメントセクション ==
09
87	ここからサイズ
80
80
80
00	ここまでサイズ → 0x7 = 7バイト
010041010B0101
== エレメントセクション おわり==

== コードセクション ==
0A
CD	ここからサイズ
82
80
80
00	ここまでサイズ → 0x14D = 333バイト

11	# of codes = 17

[main()?]
04	code size = 4バイト
00	# of variables = 0
10	call
0D	13番関数
0B	End of Code

[]
52	code size = 82バイト

01	# of variables = 1
0A(?)	ローカル変数のサイズ = 10バイト？？
7F	ローカル変数のタイプ = i32

23	global.get
00	0番グローバル変数をスタックに読み込む．{グローバル変数値}
21	local.set: スタックの先頭データを局所01番に書き込む．{空}
01	局所01番を指定
41	i32.const：以下の値（0x10）をスタックに入れる．この時点でスタックは{0x10}
10	0x10 = 16
21	local.set: スタックの先頭データ(0x10)を局所02番に書き込む．{空}
02	局所02番を指定
20	local.get ($1)：続く番号（$1）の局所01番をスタックに入れる．この時点でスタックは{局所01番値}
01	局所01番を指定
20	local.get ($2)：続く番号（$2）の局所02番をスタックに入れる．この時点でスタックは{局所01番値, 局所02番値}(右が先頭)
02	局所02番を指定
6B	i32.sub: スタックの2番目 - 1番目 = 局所1番 - 局所2番．{subの結果}
21	local.set: スタックの先頭データを局所03番に書き込む．{空}
03	局所03番を指定
20	local.get ($3)：続く番号（$3）の局所03番をスタックに入れる．この時点でスタックは{局所03番値}
03	局所03番を指定
20	local.get ($0)：続く番号（$0）の局所00番をスタックに入れる．この時点でスタックは{局所03番値, 局所01番値}
00	局所01番を指定
36	i32.sore: スタックの先頭の値をベースアドレスとしてストアする．実際の参照アドレスは2行下を参照．
02	align = 2：アラインメントは 2^2=4 となる
	★WebAssembly Specification Release 2.0で確認済．
	参照アドレスが4の倍数であることを実行環境がチェックするための情報で，とりあえず無視してよい．
0C	offset(address) = 0x0C(局所01番値)：参照アドレス＝ベースアドレス＋オフセット となる．
	（参考：https://rsms.me/wasm-intro#addressing-memory）
	したがって，ここでの参照アドレスは 局所01番値+0C となる．
	スタックは{局所03番値, 局所01番値}であったので，局所03番値がメモリにストアされる．この時点でスタックは{空}
20	local.get ($3)：続く番号（$3）の局所03番をスタックに入れる．この時点でスタックは{局所03番値}
03	局所03番を指定

28	i32.load：スタックの先頭の値をベースアドレスとしてロードする．実際の参照アドレスは2行下を参照．
02	align = 2：アラインメントは 2^2=4 となる
0C	offset(address) = 0x0C(局所03番値)：参照アドレス＝ベースアドレス＋オフセット となる．
	この時点で，スタックにはロードした値が入っている．{ロードした値}
21	local.set: スタックの先頭データ(ロードした値)を局所04番に書き込む．{空}
04	局所04番を指定
41	i32.const：以下の値（0x00）をスタックに入れる．この時点でスタックは{0x00}
00	0x00 = 0
21	local.set: スタックの先頭データ(0x00)を局所05番に書き込む．{空}
05	局所05番を指定
20	local.get ($5)：続く番号（$5）の局所05番をスタックに入れる．この時点でスタックは{局所05番値}
05	局所05番を指定

28	i32.load：スタックの先頭の値をベースアドレスとしてロードする．実際の参照アドレスは2行下を参照．
02	align = 2：アラインメントは 2^2=4 となる
80	オフセット一部：04-80-80 -> 1_0000_0000_0000_0000 = 0x10000
80	オフセット一部
04	オフセット一部
	参照アドレス = 局所05番値 + 0x10000．ロード後，スタックは{ロードした値}
21	local.set: スタックの先頭データ(ロードした値)を局所06番に書き込む．{空}
06	局所06番を指定
20	local.get ($6)：続く番号（$6）の局所06番をスタックに入れる．この時点でスタックは{局所06番値}
06	局所06番を指定
20	local.get ($4)：続く番号（$4）の局所04番をスタックに入れる．この時点でスタックは{局所06番値, 局所04番値}
04	局所04番を指定
6A	i32.add: スタックの先頭の２つを加算（スタックの2番目 + 1番目）して，スタックに入れる．スタックは{加算値}．
21	local.set: スタックの先頭データ(加算値)を局所07番に書き込む．{空}
07	局所07番を指定
41	i32.const：以下の値（0x00）をスタックに入れる．この時点でスタックは{0x00}
00	0x00 = 0
21	local.set: スタックの先頭データ(ロードした値)を局所08番に書き込む．{空}
08	局所08番を指定
20	local.get ($8)：続く番号（$8）の局所08番をスタックに入れる．この時点でスタックは{局所08番値}
08	局所08番を指定
20	local.get ($7)：続く番号（$7）の局所07番をスタックに入れる．この時点でスタックは{局所08番値, 局所07番値}
07	局所08番を指定
36	i32.sore: スタックの先頭の値をベースアドレスとしてストアする．実際の参照アドレスは2行下を参照．
02	align = 2：アラインメントは 2^2=4 となる
80	オフセット一部：04-80-80 -> 1_0000_0000_0000_0000 = 0x10000
80	オフセット一部
04	オフセット一部
	参照アドレス = 局所07番値 + 0x10000に局所08番値をストアする．ストア後，スタックは{空}
41	i32.const：以下の値（0x00）をスタックに入れる．この時点でスタックは{0x00}
00	0x00 = 0
21	local.set: スタックの先頭データ(0x00)を局所09番に書き込む．{空}
09	局所09番を指定
20	local.get ($9)：続く番号（$9）の局所09番をスタックに入れる．この時点でスタックは{局所09番値}
09	局所09番を指定
28	i32.load：スタックの先頭の値をベースアドレスとしてロードする．実際の参照アドレスは2行下を参照．
02	align = 2：アラインメントは 2^2=4 となる
80	オフセット一部：04-80-80 -> 1_0000_0000_0000_0000 = 0x10000
80	オフセット一部
04	オフセット一部
	参照アドレス = 局所09番値 + 0x10000からロードし，スタックに入れる．スタックは{ロード値}
21	local.set: スタックの先頭データ(ロード値)を局所0A番に書き込む．{空}
0A	局所0A番を指定

20	local.get ($10)：続く番号（$10）の局所0A番をスタックに入れる．この時点でスタックは{局所0A番値}
0A	局所0A番を指定
0F	Return
0B	End of Code

[]
4C	76バイト
01097F23002100411021
01200020016B21022002
24004100210320022003
36020C41142104200410
02210520022005360208
20022802082106411021
07200220076A21082008
240020060F0B

[]
11	17バイト
0002404101450D001001
0B10031007000B

[]
02	2バイト
000B

[]
2B	43バイト
01017F41002100024041
0041004D0D0003402000
417C6A22002802001101
00200041004B0D000B0B
10050B

[]
0D	13バイト
00100510061005200010
08000B

[]
07	7バイト
0020001000000B

[]
04	4バイト
0023000B

[]
06	6バイト
00200024000B

[]
12	18バイト
01027F230020006B4170
712201240020010B

[]
04	4バイト
0023000B

[]
12	18バイト
00418080042402410041
0F6A41707124010B

[]
07	7バイト
00230023016B0B

[]
04	4バイト
0023020B

[]
04	4バイト
0023010B

[]
06	6バイト
00418480040B

== コードセクション おわり==

== データセクション ==
0B
8C	ここからサイズ
80
80
80
00	ここまでサイズ → 0xC = 12バイト
0100418080040B040A000000
== データセクション おわり==